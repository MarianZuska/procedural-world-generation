#pragma kernel CSMain 
#include "./Noise.compute"
#include "./MarchTables.compute"

int numPointsPerAxis;

float surfaceLevel;
float perlinZoom;
float3 minSectorPos;
float3 minCornerPos;
float3 offsetVec;
float worldZoom;

int airSphereCount;
int groundSphereCount;
int sphereRadius;

struct Triangle {
	float3 vertexC;
	float3 vertexB;
	float3 vertexA;
};

AppendStructuredBuffer<Triangle> triangles;
StructuredBuffer<float3> airSpheres;
StructuredBuffer<float3> groundSpheres;
RWStructuredBuffer<int> numTris;

//checks if the given point is inside on of the spheres
bool insideAnySphere(float3 pos, int sphereCount, StructuredBuffer<float3> spheres) {
	if(sphereCount > 0) {
		for(int i=0; i<sphereCount; i++) {
			float3 sphere = spheres[i];
			float distToCircle2 = (pos.x - sphere.x)*(pos.x - sphere.x) + (pos.y - sphere.y)*(pos.y - sphere.y) + (pos.z - sphere.z)*(pos.z - sphere.z);
			float sphereRadius2 = sphereRadius * sphereRadius;

			if (distToCircle2 <= sphereRadius2) {
				return true;
			}
		}
	}

	return false;
}

//samples a point in 3d space, returns surface value
float samplePoint(float3 pos) {
	
	if(insideAnySphere(pos, airSphereCount, airSpheres)) return 1;
	if(insideAnySphere(pos, groundSphereCount, groundSpheres)) return -1;

	pos /= numPointsPerAxis;
	pos *= perlinZoom;
	pos += offsetVec;

	return snoise(pos);
}


//index of the curent corner configuration in the marchtable
int index(float3 pos) {
	int cubeIndex = 0;

	for (int i = 0; i < 8; i++) {
		float val = samplePoint(pos + cornerOffsets[i]);
		if (val < surfaceLevel) {
			//set i'th bit if below surface
			cubeIndex |= 1 << i;
		}
	}
	return cubeIndex;
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	int x = id.x;
	int y = id.y;
	int z = id.z;

	minCornerPos = minSectorPos + float3(x, y, z);

	//lookup table index
	int lookupIndex = index(minCornerPos);

	//iterate through triangleTable
	int nextVertIndex = 0;
	while (triangleTable[lookupIndex][nextVertIndex] != -1) {

		//append single triangle
		Triangle tri;
		for (int i = 0; i < 3; i++) {
			//get endpoints of edges
			int edgeIndex = triangleTable[lookupIndex][nextVertIndex + i];
			float3 vert1 = minCornerPos + edgeVertexOffsets[edgeIndex][0];
			float3 vert2 = minCornerPos + edgeVertexOffsets[edgeIndex][1];

			//interpolate:
			float val1 = samplePoint(vert2);
			float val2 = samplePoint(vert1);

			float diff;
			if ((surfaceLevel > val1 && surfaceLevel > val2) || (surfaceLevel < val1 && surfaceLevel < val2) || val1 == val2) {
				diff = 0.5f;
			}
			else {
				diff = (surfaceLevel - val1) / (val2 - val1);
			}

			float3 mid = vert2 + diff * (vert1 - vert2);

			//mid *= worldZoom; //for zoom, but wrong sectors

			mid += offsetVec;
						
			if (i == 0) {
				tri.vertexA = mid;
			} else if (i == 1) {
				tri.vertexB = mid;
			}
			else {
				tri.vertexC = mid;
			}
		}

		triangles.Append(tri);
		numTris.IncrementCounter();
		nextVertIndex += 3;
	}
}
